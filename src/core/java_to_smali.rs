use anyhow::{format_err, Context, Result};
use once_cell::sync::Lazy;
use regex::Regex;
use std::{
    fs,
    path::{Path, PathBuf},
};
use tracing::debug;

use crate::{
    deps::{BAKSMALI, DX},
    dir::{binarydir, temppath},
};

#[derive(Debug, Clone)]
struct JavaFile {
    /// full path of java file to compile
    path: PathBuf,
    /// pacakge path of java, e.g "com/abc/def"
    package: PathBuf,
}

impl JavaFile {
    fn new(path: &Path) -> Result<(Self, PathBuf)> {
        fn path_strip_suffix(p: &Path, suffix: &Path) -> Option<PathBuf> {
            // std library doesn't supply method to strip suffix, this is a trick method
            let p = p.to_str()?;
            let suffix = suffix.to_str()?;
            p.strip_suffix(suffix).map(PathBuf::from)
        }

        let content = fs::read_to_string(&path).with_context(|| format!("{path:?} read error"))?;
        // java can have no pacakge
        let package = parse_pacakge_path(&content).unwrap_or_default();

        let (parent, _name) = match (path.parent(), path.file_name()) {
            (Some(parent), Some(name)) => (parent, name),
            _ => return Err(format_err!("{path:?} path name invalid")),
        };

        let work_dir = path_strip_suffix(parent, &package)
        .with_context(|| format!("file folder({parent:?} is not conform to package({package:?}), Is file in correct folder?"))?;

        Ok((
            Self {
                path: path.to_owned(),
                package,
            },
            work_dir,
        ))
    }

    fn class_file(&self) -> PathBuf {
        self.path.with_extension("class")
    }

    fn smali_relative_to(&self, to: &Path) -> Result<PathBuf> {
        let path = to
            .join(&self.package)
            .join(
                self.path
                    .file_name()
                    .with_context(|| format!("invalid path: {:?}", self.path))?,
            )
            .with_extension("smali");
        Ok(path)
    }
}

struct JavaFileContext {
    files: Vec<JavaFile>,
    work_dir: PathBuf,
}

impl JavaFileContext {
    fn from_files<P: AsRef<Path>>(files: &[P]) -> Result<Self> {
        let mut base: Option<(JavaFile, PathBuf)> = None;
        let files = files
            .iter()
            .map(|p| JavaFile::new(p.as_ref()))
            .collect::<Result<Vec<_>>>()?
            .into_iter()
            .map(|(file, work_dir)| {
                if let Some((base_file, base_dir)) = &base {
                    if base_dir != &work_dir {
                        Err(format_err!(
                            "java root dir is inconsist. {:?}({base_dir:?}) VS {:?}({work_dir:?})",
                            base_file.path,
                            file.path
                        ))
                    } else {
                        Ok(file)
                    }
                } else {
                    base = Some((file.clone(), work_dir));
                    Ok(file)
                }
            })
            .collect::<Result<Vec<_>>>()?;
        let base = base.context("bug??")?;

        debug!(
            "found {} java files, java root is {:?}",
            files.len(),
            base.1
        );
        Ok(Self {
            files,
            work_dir: base.1,
        })
    }

    fn java_files(&self) -> Vec<&Path> {
        self.files
            .iter()
            .map(|e| e.path.as_ref())
            .collect::<Vec<_>>()
    }

    fn class_files(&self) -> Vec<PathBuf> {
        self.files.iter().map(|e| e.class_file()).collect()
    }

    fn compile(self) -> Result<()> {
        // compile .java to .class(javac)
        crate::cmd::compile_java(&self.java_files(), &self.work_dir)?;

        // compile .class to .dex (dx)
        // .class should generated by below command
        let class_files = self.class_files();
        let dx_jar = DX.release_binary(binarydir())?;
        let out_dex = temppath("tmp.dex");
        crate::cmd::dx_class_to_dex(&class_files, &self.work_dir, &dx_jar, out_dex.as_ref())?;
        // class files is not not need, remove it
        for file in class_files {
            fs::remove_file(file).ok();
        }

        // compile .dex to .smali (baksmali)
        let out_smalis = temppath("tmp.smalis");
        let baksmali_jar = BAKSMALI.release_binary(binarydir())?;
        crate::cmd::baksmali(out_dex.as_ref(), out_smalis.as_ref(), &baksmali_jar)?;

        // copy smali to dest dir
        for file in self.files {
            let smali = file.smali_relative_to(out_smalis.as_ref())?;
            let dest = file.path.with_extension("smali");
            fs::rename(&smali, &dest)
                .with_context(|| format!("copy from {smali:?} to {dest:?} error"))?;
        }

        Ok(())
    }
}

fn parse_pacakge_path(content: &str) -> Option<PathBuf> {
    static RE: Lazy<Regex> =
        Lazy::new(|| Regex::new(r"\bpackage\s+(?P<pathes>(\w+\.)*\w+)\s*;").unwrap());

    let mut path = PathBuf::new();
    RE.captures(content)?
        .name("pathes")?
        .as_str()
        .split('.')
        .filter(|s| !s.trim().is_empty())
        .for_each(|s| path.push(s.trim()));
    Some(path)
}

fn compile_java_file(file: PathBuf) -> Result<()> {
    let ctx = JavaFileContext::from_files(&[file])?;
    ctx.compile()?;
    Ok(())
}

fn compile_dir(dir: PathBuf) -> Result<()> {
    let files = walkdir::WalkDir::new(&dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| {
            e.path().is_file() && e.path().extension().map(|s| s == "java").unwrap_or(false)
        })
        .map(|e| e.path().to_path_buf())
        .collect::<Vec<_>>();
    if files.is_empty() {
        return Err(format_err!("no java file found in {dir:?}"));
    }
    let ctx = JavaFileContext::from_files(&files)?;
    ctx.compile()?;
    Ok(())
}

pub fn java_to_smali(path: &str) -> Result<()> {
    let path = fs::canonicalize(path).with_context(|| format!("{path:?} not exists"))?;
    if path.is_file() && path.extension().map(|ext| ext == "java").unwrap_or(false) {
        compile_java_file(path)
    } else if path.is_dir() {
        compile_dir(path)
    } else {
        Err(format_err!("{path:?} invalid"))
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_regex() {
        eprintln!(
            "{:?}",
            super::parse_pacakge_path("package com.bytedance.secsdk;").unwrap()
        );
    }
}
